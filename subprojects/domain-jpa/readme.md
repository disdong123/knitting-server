#
JPA 와 관련된 로직을 작성합니다.

도메인 관련 로직을 작성합니다. JPA 에 대한 의존을 제거합니다.

객체 정의
Post 를 기준으로 설명합니다.

PostDo: 순수한 도메인 객체입니다. 도메인 관련 로직이 작성됩니다.
PostEntity: JPA Entity 입니다.
PostDoImpl: JPA Entity 와 PostDo 가 만나는 객체입니다. Service 단에서 사용되고, 컨트롤러로 반환될땐 PostDo 또는 다른 DTO 로 반환됩니다.
OAuth 2.0
Resource Owner: 실제 자원의 소유주입니다. (고객)
Resource Server: 자원을 관리하는 서버입니다.
Client: Resource owner 대신 자원에 접근하길 원하는 어플리케이션입니다.
Authorization Server: OAuth 2.0 access token 을 Client 에게 발행하는 서버입니다. 보통 Resource Server 가 이 역할을 함께 합니다.
OAuth 2.0 에서는 클라이언트가 자원 소유자 대신 자원에 접근하는 인가 승인을 얻는 방법은 정의합니다. 즉, 명확한 목적을 갖고 자원에 접근하게 되는데, 이 목적을 scope 혹은 이라고 합니다.

OIDC
OAuth 2.0 은 인가에 관한 것으로, 클라이언트는 리소스 오너에 대한 정보를 전혀 몰라도 됩니다. 물론 엑세스 토큰을 받으면 리소스 서버에 접근하여 사용자 정보를 받아올 수 있지만, 한 번 더 요청을 해야되므로 비효율적입니다.

OIDC 는 OAuth 2.0 위에 ID 계층을 도입하여 구축된 프로필입니다. 이 ID 계층은 JWT 인 ID 토큰으로 추상화되며, OIDC 를 지원하는 OAuth 2.0 인가 서버는 액세스 토큰과 함께 ID 토큰을 발급해줍니다.

이렇게 발급받은 ID 토큰에는 사용자의 정보를 포함하고 있습니다.

승인방식
OAuth 2.0 에는 다섯개의 승인 방식이 있습니다.

인가코드 승인방식
먼저 자원 소유자로부터 인가코드 승인방식이 시작됩니다.

인가 서버에 등록돼야하는 클라이언트 어플리케이션은 승인을 받고자 자원 소유자를 인가 서버로 리다이렉트 시킵니다.

아래는 클라이언트 어플리케이션에서 사용자를 인가 서버의 인가 종단점으로 리다이렉트시키는 동안 만들어진 요청입니다. 예제

https://kauth.kakao.com/oauth/authorize?
client_id=${REST_API_KEY}&
redirect_uri=${REDIRECT_URI}&
response_type=code&
scope=openid               // **OIDC 를 위한 파라미터입니다.**
response_type 의 code 는 인가 서버에 이 요청이 인가 코드를 위한 것이라는 것을 나타냅니다.
client_id: 클라이언트 어플리케이션을 위한 식별자로, 클라이언트 어플리케이션이 인가 서버에 등록되면 클라이언트는 client_id 와 client_secret 을 얻습니다.
kakao 의 경우 client_secret 은 필수값이 아닙니다. 토큰 발급 시, 보안 강화를 위해 추가로 설정할 수 있습니다. 참고
redirect_uri: 클라이언트 등록 단계에서 제공하는 uri 입니다.
만약 OIDC 를 사용한다면 scope 에 openid 를 지정해주어야합니다.
리소스 오너가 필요로하는 인증을 완료하면 Authorization Server 는 인가 코드와 함께 redirect_uri 로 리다이렉트 해줍니다. 이러한 인가 코드는 유효기간이 있을 수 있는데, 1분 이상의 유효기간은 권장하지 않습니다.

HTTP/1.1 302 Found
Content-Length: 0
Location: ${REDIRECT_URI}?code=${AUTHORIZE_CODE}
이렇게 받은 인가 코드로는 어떠한 리소스에도 접근할 수 없습니다. 따라서, 클라이언트는 인가 코드를 이용하여 자원에 실제로 접근할 수 있는 Access token 을 발급받아야 합니다.

예제

# 요청
curl -v -X POST "https://kauth.kakao.com/oauth/token" \
-H "Content-Type: application/x-www-form-urlencoded" \
-d "grant_type=authorization_code" \           // 반드시 authorization_code 여야합니다.
-d "client_id=${REST_API_KEY}" \
--data-urlencode "redirect_uri=${REDIRECT_URI}" \
-d "code=${AUTHORIZE_CODE}"
# 응답
HTTP/1.1 200 OK
{
"token_type": "bearer",                  // 토큰 유형
"access_token": "${ACCESS_TOKEN}",
"id_token": "${ID_TOKEN}",               // **OIDC 를 설정한 경우에만 받습니다.**
"expires_in": 7199,
"refresh_token": "${REFRESH_TOKEN}",
"refresh_token_expires_in": 86399,
"scope": "profile_image openid profile_nickname"
}
아래는 ID 토큰의 페이로드 예시입니다.

{
"aud": "${APP_KEY}",
"sub": "${USER_ID}",
"auth_time": 1661967952,
"iss": "https://kauth.kakao.com",
"exp": 1661967972,
"iat": 1661967952,
"nickname": "JordyTest",
"picture": "http://yyy.kakao.com/.../img_110x110.jpg",
"email": "jordy@kakao.com"
}
클라이언트는 인가 코드를 한 번만 사용해야 하며, 두번이상 사용됨을 감지하면 해당 인가 코드로 방행된 모든 Access Token 을 Invalid 하게 해야합니다.

클라이언트 자격증명 승인유형
어플리케이션이 API 자체에 접근하려는 경우에 사용됩니다.

토큰 유형
OAuth 2.0 에서는 어떤 토큰 유형에도 종속되지 않습니다.

OAuth 2.0 에는 두가지 주요 토큰 프로필인 Bearer token profile 과 MAC token profile 이 있고, 일반적으로 bearer 를 많이 사용합니다.

Bearer token profile 은 토큰을 소유한 사람은 누구나 토큰을 사용할 수 있으며 Bearer token 은 전송 중에 손실되지 않도록 항상 TLS 를 사용해야 합니다.

인가 서버에서 Bearer access token 을 확보하면 클라이언트가 이 토큰을 이용하여 자원 서버와 통신할 수 있는 방법이 RFC 6750 에 세가지 정의되어 있는데, 그 중 하나가 바로 HTTP Authorization 헤더에 토큰을 포함시키는 것입니다.

GET /resource HTTP/1.1
Host: example.com
Authorization: Bearer <token>
query 파라미터로 넣을 수도 있는데, 파라미터의 이름은 access_token 이어야합니다. (일부 provider 는 다른 명칭을 쓰기도 합니다.)

GET /resource?access_token=<token>
Host: example.com
토큰을 인코딩된 형식으로 body 에 넣을 수도 있으며, Bearer token profile 을 지원하는 인가 서버는 아래 요청을 처리할 수 있어야 합니다.

GET /resource HTTP/1.1
Host: example.com
Content-type: application/json
access_token=<token>
TLS
두 개의 호스트가 다양한 네트워크를 통해 데이터를 주고받는데, 기본적으로 HTTP 프로토콜은 plain text 형태로 네트워크 상에서 전달됩니다.

즉, 중간에 가로채서 데티러를 확인할 수 있다.

HTTP 에 TLS 이란는 보안 채널을 중간에 삽입시켜서 데이터를 암호화할 수 있게 해준다.

img.png

TLS 프로토콜
위 처럼 TLS 는 어플리케이션 계층과 전송 계층 사이에 위치합니다.

간단히 OSI 7 계층에 대해 알아보면,

HTTP 는 전송 계층 프로토콜과는 무관한 어플리케이션 계층 프로토콜입니다. 즉, HTTP 는 패킷이 다른 호스트로 어떻게 전송되는지 전혀 신경쓰지 않고, 전송계층에서 정의된 TCP 나 UDP 에 의해 결정됩니다.

그러나 대부분 HTTP 트래픽은 TCP 를 통해 이동하는데, 데이터 전송중에 손실된 데이터의 재전송, 순서보장, 혼잡제어, 데이터 무결설 확보 등 여러 작업을 하는 TCP 의 특성 때문입니다.

그리고 TCP 는 인터넷 계층 프로토콜이 어떻게 동작하는지 전혀 신경쓰지 않습니다. IP 는 메시지 창구에 하드웨어 독립적인 주소 지정 체계를 제공합니다.

마지막으로 네트워크 계층을 통해 물리적인 네트워크를 통해 메시지가 전달됩니다.

TCP 는 연결지향 프로토콜로, 모든 클라이언트와 서버의 연결은 핸드쉐이크로 이뤄집니다.

TCP 핸드쉐이크 과정이 종료되면 TLS 의 자체 핸드쉐이크 과정이 시작되는데, 이때 클라이언트/서버 간에 각자 생성한 난수, 지원하는 TLS 프로토콜 버전, TLS 인증서 등 보안을 위한 여러 데이터를 주고 받고, 보안 채널이 연결됩니다.

TLS 와 SSL 의 차이
TLS 는 SSL (Secure Sockets Layer) 에 뿌리를 둡니다.

지금까지 넷스케이프, 마이크로소프트 등 여러 공급업체가 동일한 문제를 다른 방식으로 해결하면서 PCT, SSL 3.0 등이 등장했습니다.

이를 정리하여, 합의 하에 SSL 3.0 을 기반으로 하여 TLS 1.0 을 출시했고, SSL 3.0 과 큰 차이는 없지만 상호 호환은 되지 않습니다.

SSL/TLS 인증서
HTTPS 를 위해 발급받는 SSL/TLS 인증서는 SSL, TLS 중 어떤 프로토콜을 사용하느냐에 따라 달라지지 않습니다. SSL, TLS 를 모두 지원하는 인증서라 해석하는 것이 옳습니다.

SSL/TLS 인증서는 SSL/TLS 프로토콜을 사용하여 웹 브라우저가 웹 사이트에 대해 암호화된 네트워크 연결을 확인하고 설정할 수 있게 해줍니다.

인증서는 다음 과정으로 발급됩니다.

발급받을 주체가 CA 에 도메인, 공개키 등을 제출합니다.
CA 는 해당 정보를 검토하고, 주체의 공개키를 SHA-256 등으로 해싱하여 지문으로 등록합니다.
이 지문을 CA 의 개인키로 암호화하여 인증서에 서명하고, 도메인 명, 인증기관, 퍼블릭 키, TLS 버전 등이 명시되어있는 인증서를 발급해줍니다.
CA 는 공인된 기관으로, 브라우저는 모든 CA 리스트와 공개키를 갖고있고 이를 통해 서버의 인증서를 확인합니다.

HTTPS 와 HTTP
HTTP 는 TCP/IP 스택의 어플리케이션 계층에서 동작하지만 TLS 는 어플리케이션 계층과 전송계층 사이에서 동작합니다.

HTTPS 를 이용하려면 서버는 먼저 ssl/tls 관련 설정을 켜주고, 인증서를 등록해야 합니다. (스프링에서는 server.ssl 관련 설정을 해줍니다.)

HTTP 클라이언트 역할을 하는 브라우저는 서버에서 특정 포트(443)에 대한 연결을 열어 TLS 핸드쉐이크를 시작하는 TLS 클라이언트 역할도 해야합니다.

TLS 핸드쉐이크가 완료된 후에만 에이전트가 어플리케이션 데이터를 교환해야 하고, 모든 HTTP 데이터는 TLS 어플리케이션 데이터로 전송됩니다.

일반 HTTP 트래픽과 TLS 를 통한 HTTP 트래픽에 대한 구분을 위해 HTTPS 가 정의되었습니다.

기밀성 보장
기밀성은 전송중인 데이터를 의도하지 않은 수신자로부터 보호하는 방법에 관한 것으로, 일반적으로 암호화로 전송 채널을 보호해 기밀성을 확보합니다.

전송채널이 HTTP 인 API 는 HTTPS 라는 TLS 를 사용하는 HTTP 를 이용할 수 있습니다.

TLS 는 말 그대로, 전송계층 암호화로, 메시지가 전송되는 동안만 보호해주고 전송채널(HTTPS)을 떠나는 순간 안전하지 않습니다.

만약 메시지 수준 암호화로 데이터를 보호하는 경우에는 HTTP 처럼 안전하지 않은 채널을 이용할 수도 있습니다.

무결성 보장
무결성은 데이터의 정확성과 신뢰성을 보장하며 무단 수정을 탐지하는 것으로, 전송 중에 데이터가 변경되지 않게 하려면 의도된 당사자만 이용할 수 있는 보안 채널인 TLS 를 이용할 수 있습니다.

##########

HTTPS 는

처음 클라이언트가 서버에 요청을 보내면 서버에서는 Public key 를 넘겨준다.

브라우저는 브라우저만의 private key 가 생성되는데, 받은 public key 로 private key 를 암호화하여 서버로 전달한다.

서버는 private key 로 브라우저의 private key 를 복호화해서 가지고 있는다.

서버와 브라우저는 서로가 갖고있는 퍼블릭, 프라이빗 키로 하나의 키를 새로 만들고, 이 둘의 키는 완전히 동일해진다.

이제 plain text 는 이 키를 통해 암호화되어 통신하게된다

서버는 CA 에 공개키를 주고 인증서를 구입한다.

CA 는 자신의 프라이빗키로 암호화하여 인증서를 준다.

웹 브라우저가 서버에 접속할 때 서버는 제일 먼저 인증서를 제공한다. 브라우저는 이 인증서를 발급한 CA가 자신이 내장한 CA의 리스트에 있는지를 확인한다. 확인 결과 서버를 통해서 다운받은 인증서가 내장된 CA 리스트에 포함되어 있다면 해당 CA의 공개키를 이용해서 인증서를 복호화 한다.

해당 CA의 비공개 키를 가지고 있는 CA는 해당 CA 밖에는 없기 때문에 서버가 제공한 인증서가 CA에 의해서 발급된 것이라는 것을 의미한다.

CA에 의해서 발급된 인증서라는 것은 접속한 사이트가 CA에 의해서 검토되었다는 것을 의미하게 된다.

CA의 검토를 통과했다는 것은 해당 서비스가 신뢰 할 수 있다는 것을 의미한다. 이것이 CA와 브라우저가 특정 서버를 인증하는 과정이다.

SSL 인증서는 클라이언트와 서버간의 통신을 제3자가 보증해주는 전자화된 문서다. 클라이언트가 서버에 접속한 직후에 서버는 클라이언트에게 이 인증서 정보를 전달한다. 클라이언트는 이 인증서 정보가 신뢰할 수 있는 것인지를 검증 한 후에 다음 절차를 수행하게 된다. SSL과 SSL 디지털 인증서를 이용했을 때의 이점은 아래와 같다.

통신 내용이 공격자에게 노출되는 것을 막을 수 있다. 클라이언트가 접속하려는 서버가 신뢰 할 수 있는 서버인지를 판단할 수 있다. 통신 내용의 악의적인 변경을 방지할 수 있다.

대칭키
대칭키는 동일한 키로 암호화와 복호화를 같이 할 수 있는 방식의 암호화 기법을 의미한다. 즉 암호화를 할 때 1234라는 값을 사용했다면 복호화를 할 때 1234라는 값을 입력해야 한다는 것이다.

대칭키 방식은 단점이 있다. 암호를 주고 받는 사람들 사이에 대칭키를 전달하는 것이 어렵다는 점이다. 대칭키가 유출되면 키를 획득한 공격자는 암호의 내용을 복호화 할 수 있기 때문에 암호가 무용지물이 되기 때문이다

공개키
공개키 방식은 두개의 키를 갖게 되는데 A키로 암호화를 하면 B키로 복호화 할 수 있고, B키로 암호화하면 A키로 복호화 할 수 있는 방식이다. 이 방식에 착안해서 두개의 키 중 하나를 비공개키(private key, 개인키, 비밀키라고도 부른다)로하고, 나머지를 공개키(public key)로 지정한다. 비공개키는 자신만이 가지고 있고, 공개키를 타인에게 제공한다. 공개키를 제공 받은 타인은 공개키를 이용해서 정보를 암호화한다. 암호화한 정보를 비공개키를 가지고 있는 사람에게 전송한다. 비공개키의 소유자는 이 키를 이용해서 암호화된 정보를 복호화 한다. 이 과정에서 공개키가 유출된다고해도 비공개키를 모르면 정보를 복호화 할 수 없기 때문에 안전하다. 공개키로는 암호화는 할 수 있지만 복호화는 할 수 없기 때문이다.

CA
인증서의 역할은 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지를 보장하는 역할을 한다. 이 역할을 하는 민간기업들이 있는데 이런 기업들을 CA(Certificate authority) 혹은 Root Certificate 라고 부른다. CA는 아무 기업이나 할 수 있는 것이 아니고 신뢰성이 엄격하게 공인된 기업들만이 참여할 수 있다.

SSL을 통해서 암호화된 통신을 제공하려는 서비스는 CA를 통해서 인증서를 구입해야 한다

핸드쉐이크를 하는데, 이 때 SSL 인증서를 주고 받는다.

HTTP 는 전송 계층 프로토콜과는 무관한 어플리케이션 계층 프로토콜입니다. 즉, HTTP 는 패킷이 다른 호스트로 어떻게 전송되는지 전혀 신경쓰지 않고, 전송계층에서 정의된 TCP 나 UDP 에 의해 결정됩니다.

그러나 대부분 HTTP 트래픽은 TCP 를 통해 이동하는데, 데이터 전송중에 손실된 데이터의 재전송, 순서보장, 혼잡제어, 데이터 무결설 확보 등 여러 작업을 하는 TCP 의 특성을 이용합니다.

반면, TCP 는 인터넷 계층 프로토콜이 어떻게 동작하는지 전혀 신경쓰지 않습니다. IP 는 메시지 창구에 하드웨어 독립적인 주소 지정 체계를 제공합니다.

마지막으로 네트워크 계층을 통해 물리적인 네트워크를 통해 메시지가 전달됩니다.

TCp 는 연결지향 프로토콜로, 모든 클라이언트와 서버의 연결은 핸드쉐이크로 이뤄집니다.

TLS 는 전송계층보안 프로토콜로, 핸드세이크와 데이터 전송의 두 단계로 나뉩니다.

TLS 핸드쉐이크
TCP 의 핸드쉐이크와 비슷하게 TLS 자체 핸드쉐이크를 이용합니다. 여기에는 어플리케이션 데이터를 보호하는 데 사용할 암호화 키에 대해 클라이언트와 서버 간에 합의를 시켜주는 Handshake 프로토콜,

클라이언트와 서버 모두 Change Cipher spec 프로토콜로 추가 통신을 위해 암호화 보안 채널로 전환할 것임을 서로에게 표시하고, Alert 프로토콜로 경고를 생성하고 TLS 연결에 관련된 당사자에게 알리는 역할을 한다.

TLS 핸드쉐이크는 TCP 입장에서는 어플리케이션 데이터일 뿐이므로 TCP 핸드쉐이크 후에 시작합니다.

클라이언트는 자신이 생성한 난수, 지원하는 모든 암호화 알고리즘, 지원하는 TLS 프로토콜 가장 높은 버전, 섹션 식별자 등을 첫번째 메시지로 보냅니다. 2. TLS 핸드쉐이크는 CPU 에 부하를 많이주므로 세션을 통해 핸드쉐이크를 처음부터 다시 수행하지 않도록 합니다.
클라이언트에게 메시지를 받으면 서버는 SSL 인증서, 클라이언트와 서버가 지원할 수 있는 가장 높은 버전의 TLS 프로토콜, 서버에서 생성된 난수, 가장 강력한 암호화 스위트, C/S 가 모두 지원할 수 있는 압축 알고리즘 등을 메시지로 보냅니다.
TLS 란
TLS 는 SSL (Secure Sockets Layer) 에 뿌리를 둡니다.

넷스케이프, 마이크로소프트 등 여러 공급업체가 동일한 문제를 다른 방식으로 해결하면서 PCT, SSL 3.0 등이 등장했습니다.

이후, 합의하에 TLS 1.0 을 출시했고, SSL 3.0 과 큰 차이는 없지만 상호 호환은 되지 않습니다.

SSL/TLS 인증서는 SSL, TLS 중 어떤 프로토콜을 사용하느냐에 따라 달라지지 않습니다. SSL 및 TLS 와 함께 사용할 수 있는 인증서라 해석하는 것이 옳습니다.

HTTPS / HTTP
HTTP 는 TCP/IP 스택의 어플리케이션 계층에서 동작하지만 TLS 는 어플리케이션 계층과 전송계층 사이에서 동작합니다.

HTTP 클라이언트 역할을 하는 브라우저는 서버에서 443 포트에 대한 연결을 열어 TLS 핸드쉐이크를 시작하는 TLS 클라이언트 역할도 해야합니다.

TLS 핸드쉐이크가 완료된 후에만 에이전트가 어플리케이션 데이터를 교환해야 하고, 모든 HTTP 데이터는 TLS 어플리케이션 데이터로 전송됩니다.

일반 HTTP 트래픽과 TLS 를 통한 HTTP 트래픽에 대한 구분을 위해 HTTPS 가 정의되었습니다.

기밀성 보장
기밀성은 전송중인 데이터를 의도하지 않은 수신자로부터 보호하는 방법에 관한 것으로, 일반적으로 암호화로 전송 채널을 보호해 기밀성을 확보합니다.

전송채널이 HTTP 인 API 는 HTTPS 라는 TLS 를 사용하는 HTTP 를 이용할 수 있습니다.

TLS 는 말 그대로, 전송계층 암호화로, 메시지가 전송되는 동안만 보호해주고 전송채널(HTTPS)을 떠나는 순간 안전하지 않습니다.

만약 메시지 수준 암호화로 데이터를 보호하는 경우에는 HTTP 처럼 안전하지 않은 채널을 이용할 수도 있습니다.

무결성 보장
무결성은 데이터의 정확성과 신뢰성을 보장하며 무단 수정을 탐지하는 것으로, 전송 중에 데이터가 변경되지 않게 하려면 의도된 당사자만 이용할 수 있는 보안 채널인 TLS 를 이용할 수 있습니다.

// jwt 는 세개로 나뉘는데, header 는 잡다한 정보, payload 는 실제 데이터, signature 는 서버에서 secret 키를 갖고있어서 암호화된 부분
// 즉, jwt 의 헤더, 페이로드는 base64 로 그냥 인코딩되어있는거라서 누구나 수정할 수 있는데, 만약 수정이 되면 서버에서 verify 할때 오류가 나서 통과가 안됨
// 즉, jwt 를 갖고있으면 누구나 읽을순있지만 수정은 절대 불가능함. 누구나 읽을수 있으므로 중요한 정보는 넣으면 안됨.
